(set-option :print-success true)
(set-option :diagnostic-output-channel "stdout")
(set-option :produce-models true)
(set-option :print-success true)
(set-option :diagnostic-output-channel "stdout")
(set-option :produce-models true)
(set-option :produce-proofs true)
(set-option :proof-format-mode alethe)
(set-logic QF_LIA)
(push 1)
(push 1)
(declare-fun C () Int)
(declare-fun D () Int)
(declare-fun A () Int)
(declare-fun B () Int)
(assert (let ((.def_0 (<= 0 D))) (let ((.def_1 (* (- 1) C))) (let ((.def_2 (<= (- 1) .def_1))) (let ((.def_3 (<= 1 .def_1))) (let ((.def_4 (or .def_3 .def_2))) (let ((.def_5 (<= 1 C))) (let ((.def_6 (<= (- 1) C))) (let ((.def_7 (or .def_6 .def_5))) (let ((.def_8 (<= 0 .def_1))) (let ((.def_9 (or .def_8 .def_5))) (let ((.def_10 (and .def_9 .def_7 .def_4 .def_0))) (let ((.def_11 (<= 0 A))) (let ((.def_12 (<= (- 1) B))) (let ((.def_13 (<= 1 B))) (let ((.def_14 (or .def_13 .def_12))) (let ((.def_15 (* (- 1) B))) (let ((.def_16 (<= (- 1) .def_15))) (let ((.def_17 (<= 1 .def_15))) (let ((.def_18 (or .def_17 .def_16))) (let ((.def_19 (= C .def_15))) (let ((.def_20 (<= 0 .def_15))) (let ((.def_21 (or .def_20 .def_13))) (let ((.def_22 (+ .def_15 A))) (let ((.def_23 (+ B A))) (let ((.def_24 (mod B 3))) (let ((.def_25 (= .def_24 1))) (let ((.def_26 (ite .def_25 .def_23 .def_22))) (let ((.def_27 (= D .def_26))) (let ((.def_28 (and .def_27 .def_21 .def_19 .def_18 .def_14 .def_11))) (let ((.def_29 (=> .def_28 .def_10))) (let ((.def_30 (not .def_29))) .def_30))))))))))))))))))))))))))))))))
(check-sat)